## 下面哪一个是正确的？

**注意** _答案当中含有解释。即便你已经知道答案，也请逐一选择每个选项，这样可以阅读到解释。_

1. 你可以运行一个库程序包。
2. 在一个库程序包中，应该含有一个叫做 main 的函数 (func main)。
3. 你可以编译一个库程序包。*正确*
4. 你必须编译一个库程序包。

> **1:** 你不能运行，但你可以从其他包中导入它。
>
> **2:** 在一个库程序包中，没有必要包含 main 函数。因为它并非一个可执行的包。只有在可执行的包中才需要 main 函数。
>
> **4:** 你没有必要编译它。当你导入它时，它会自动在编译或运行时被其他程序或库构建。


## 在导出名称时你需要做什么？

1. 你需要将名称全部大写
2. 你需要将名称的首字母大写 *正确*
3. 你需要把名称放到一个函数作用域里
4. 你需要用这个名称创建一个新的文件

> **1:** 当你这样做时，它的确会被导出，但不要这样做；因此我认为这个答案不正确 :)
>
> **2:** 正确的。这样做之后其他包便可以访问它。
>
> **3:** 它应该在包作用域内，而不是函数作用域内。
>
> **4:** 没必要这样做。


## 你要怎么在一个可执行程序中使用一个你的库中的函数呢？

1. 你需要首先导出你的库程序包；然后你可以访问它的导入名称
2. 你需要首先导入你的库程序包；然后你可以访问它的导出名称 *正确*
3. 你可以像它本来就在你的可执行程序中一样，访问你的库程序包
4. 你可以通过使用它的名称来导入它

> **1:** 你不能导出包。所有的包都是已经导出的。除非你将它们放到一个叫做 "internal" 的目录中。但是，这是一个对于现在过于进阶的话题。
>
> **2:** 正确的。
>
> **3:** 你不能在不导入的情况下，在一个包中访问另一个包。
>
> **4:** 你不能这么做。你需要在 GOPATH 后使用完整的路径来导入它。顺带一提，在不久的将来，这可能会随着 Go 模块的支持而改变。


## 在下面的程序中，哪些名称被导出了？

```go
package wizard

import "fmt"

func doMagic() {
    fmt.Println("enchanted!")
}

func Fireball() {
    fmt.Println("fireball!!!")
}
```

1. fmt
2. doMagic
3. Fireball *正确*
4. Println

> **1:** 这是导入包的名称。
>
> **2:** 它以小写字母开头；所以，它没有被导出。
>
> **3:** 正确的。它以大写字母开头。
>
> **4:** 这不是你写的函数。它已经在 fmt 包中被导出了。但它没有在这里被导出。


## 在下面的程序中，哪些名称被导出了？

```go
package wizard
import "fmt"

var one string
var Two string
var greenTrees string

func doMagic() {
    fmt.Println("enchanted!")
}

func Fireball() {
    fmt.Println("fireball!!!")
}
```

1. doMagic 和 Fireball
2. Fireball 和 Two *CORRECT*
3. Fireball, greenTrees 和 Two
4. Fireball, greenTrees, one 和 Two

> **1:** doMagic 以小写字母开头；所以没有被导出。
>
> **2:** 正确的。Fireball 和 Two 都以大写字母开头。
>
> **3:** greenTrees  以小写字母开头；所以没有被导出。
>
> **4:** one 和 greenTrees  没有以大写字母开头；所以没有被导出。