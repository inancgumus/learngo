## 作用域是什么？
* 可执行的代码块
* 声明变量的可见性 **正确**
* 确定要运行的内容

```go
package awesome

import "fmt"

var enabled bool

func block() {
    var counter int
    fmt.Println(counter)
}
```

## 哪个变量属于包作用域
1. awesome
2. fmt
3. enabled **正确**
4. counter

> **3:** 是的， `enabled` 在任何函数之外，所以它是包作用域的变量 `block()` 也是包作用域，它也在任何函数之外
>
>


## 哪一个变量属于文件作用域？
1. awesome
2. fmt **正确**
3. enabled
4. block()
5. counter

> **2:** 没错，导入的包名称属于文件作用域，而且它们只能在同一文件中使用。
>
>


## 哪一个在 block() 函数的作用域?
1. awesome
2. fmt
3. enabled
4. block()
5. counter **正确**

> **5:** 是的， `counter` 在 `block()` 函数内部定义,所以它属于函数作用域，对 `block()` 函数外的其他代码不可见
>
>


## `block()` 函数可以看见 `enabled` 变量吗？
1. 可以: 它在包作用域里 **正确**
2. 不可以: 它在文件作用域里
3. 不可以: 它在 block() 函数作用域里

> **1:** 包作用域的变量对同一个包下所有代码都可见
>
>


## `awesome`中的其他文件可以看见 `counter` 变量吗？
1. 可以
2. 不可以: 它在包作用域里
3. 不可以: 它在文件作用域里
4. 不可以: 它在 block() 函数的作用域里 **正确**

> **4:** 没错。其他代码都无法看到 `block()` 函数内部的变量。只有在 `block()` 函数内部的代码才能看到它们 (近在一定程度上 ，例如：函数内部的代码只能看到在它们之前声明的变量)
>
>


## `awesome` 中的其他文件可以看见 `fmt` 变量吗?
1. 可以
2. 不可以: 它在包作用域里
3. 不可以: 它在文件作用域里 **正确**
4. 不可以: 它在 block() 函数的作用域里

> **3:** 只有在 import 只定义在同一个文件内，不管是不是同一个包，其他文件都不可见
>
>


## 如果在相同的作用域中声明相同的变量会发生什么？
```go
package awesome

import "fmt"

// 在包作用域中声明两次
var enabled bool
var enabled bool

func block() {
    var counter int
    fmt.Println(counter)
}
```
1. 新声明的变量将覆盖前一个变量
2. 不能这样做，它已经在包作用域中声明了 *正确*
3. 不能这样做，它已经在文件作用域中声明了

> **2:** 没错，不能在同一个作用域内声明同一个变量，如果这样做，使用变量时获取的是前一个还是后一个声明的变量？
>
>


## 如果在不同的作用域中声明相同的变量会发生什么？
```go
package awesome

import "fmt"

// 在包作用域中声明
var enabled bool

func block() {
    // 在函数作用域中声明
    var enabled bool

    var counter int
    fmt.Println(counter)
}
```
1. 新声明的变量将覆盖前一个变量 *正确*
2. 不能这样做，它已经在包作用域中声明了
3. 不能这样做，它已经在文件作用域中声明了

> **1:** 实际上，可以在内部作用域中声明相同的变量，例如 `block()`'的作用域在包作用域里面。这意味这它可以获取到包作用域的变量(反之则不同). 所以, `block()`'作用域在包作用域之内。这意味着你可以再次声明相同的变量。它会覆盖掉父作用域的变量，它们同时存在，请查看课程存储库中的示例以找出答案。
>
>
